///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>


/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

  //////////////////////////////////////////////////////////////////////
  // exported functions, classes and interfaces/types

  /**
  * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
  * @param interpretations List of possible interpretations.
  * @param currentState The current state of the world.
  * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
  */
  export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
    var errors : Error[] = [];
    var plans : PlannerResult[] = [];
    interpretations.forEach((interpretation) => {
      try {
        var result : PlannerResult = <PlannerResult>interpretation;
        result.plan = planInterpretation(result.interpretation, currentState);
        if (result.plan.length == 0) {
          result.plan.push("That is already true!");
        }
        plans.push(result);
      } catch(err) {
        errors.push(err);
      }
    });
    if (plans.length) {
      return plans;
    } else {
      // only throw the first error found
      throw errors[0];
    }
  }

  export interface PlannerResult extends Interpreter.InterpretationResult {
    plan : string[];
  }

  export function stringify(result : PlannerResult) : string {
    return result.plan.join(", ");
  }
  //////////////////////////////////////////////////////////////////////
  // private functions

  /**
  * The core planner function.
  * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
  * @param state The current world state.
  * @returns Basically, a plan is a
  * stack of strings, which are either system utterances that
  * explain what the robot is doing (e.g. "Moving left") or actual
  * actions for the robot to perform, encoded as "l", "r", "p", or "d".
  */
  function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
    var plan : string[] = [];
    //compare function defined seperatly in Graph.ts
    var graph : Graph<WorldState> = {outgoingEdges : getWorldStateEdges , compareNodes : null}
    var start : WorldState = state;

    /**
    The goal function tests if a world state is equal to the goal state,
     i.e. if the DNF-'interpretation' is fullfilled
    */
    function goal(testState : WorldState) : boolean {
      for(var i=0; i< interpretation.length ; i++){
        for(var j=0; j< interpretation[i].length ; j++){
          //check if literal is fullfilled
          if(checkLiteral(interpretation[i][j],testState)){
            //if it's the last entry in the row, the DNF is fullfilled -> one (of perhaps many) goals is reached
            if(j === interpretation[i].length-1){
              return true
            }
          }
          //otherwise go to next row
          else{
            break
          }
        }
      }
      return false
    }
    /**
    The heuristic given a world state. Is admissible.
    */
    function heuristic(testState : WorldState) : number {
      //assign a heuristic to each literal in the DNFFormula interpretation depending on how close it is to being true
      var h :number[][] = [];
      for (let i = 0; i < interpretation.length; i++) {
          h[i] = [];
          for (let j = 0; j < interpretation[i].length; j++) {
              h[i][j] = distanceCalc(testState,interpretation[i][j])
          }
      }
      //the final heuristic for the world state is the
      // i.e min( max( h of literals in DNF matrix) taken over rows ) taken over column
      //               1 2 4
      //  h of DNF =   5 3 9   =>   finalH = 4
      //               7 6 3
      var hMaxOfRows : number[]=[];
      for(var i =0; i< h.length ; i++){
        hMaxOfRows[i] = Math.max(...h[i])
      }
      return Math.min(...hMaxOfRows)
    }

    /** Gets an admissible heuristic for a signle literal depending on how
    close it is to being fullfilled in a world state
    */
    function distanceCalc(testState : WorldState, literal : Interpreter.Literal) : number{
      if (checkLiteral(literal,testState)){
        return 0;
      }
      var distance : number =0;
      var objectA : string = literal.args[0]
      var objectsAboveA : number;
      var xA : number;
      var yA : number;
      var stackA : string[];
      var coordsA : number[];
      var coordsB : number[];
      var armDistanceA : number;
      var armDistanceB : number;
      var tempCount : number;
      //If the arm is holding the object, no need to check stack height etc
      if (testState.holding == objectA){
        xA = testState.arm
        armDistanceA =0;
        objectsAboveA = 0;
      } else {
        coordsA = getCoords(objectA, testState)
        xA = coordsA[0]
        armDistanceA = Math.abs(xA-state.arm)
        yA = coordsA[1]

        stackA = testState.stacks[xA]
        //Calculate size of stack above object
        objectsAboveA = stackA.length -yA -1;
        //Adjusts for size of objects
        tempCount=0;
        for (var i = 0; i< objectsAboveA -2;i++){
          if (testState.objects[stackA[yA +i]].size == "large"){
            tempCount+=1;
          }
        }
        objectsAboveA+=tempCount;
      }

      var objectB : string = literal.args[1]
      //If no second object, relation is "holding" and the cost is straightforward to calculate
      if (objectB == undefined){
        distance+= Math.abs(xA - testState.arm) + 3*objectsAboveA
        return distance
      }
      //otherwise, calculate the same values for object B
      var objectsAboveB : number;
      var xB : number;
      var yB : number;
      var stackB : string[];

      if (testState.holding == objectB){
        xB = testState.arm
        armDistanceB=0;
        objectsAboveB = 0;
      } else {
        coordsB = getCoords(objectB, testState)
        xB = coordsB[0]
        armDistanceB = Math.abs(xB-state.arm)
        yB = coordsB[1];
        stackB = testState.stacks[xB]
        objectsAboveB = stackB.length -yB-1;
        tempCount =0;
        for (var i = 0; i< objectsAboveB-2;i++){
          if (testState.objects[stackB[yB +i]].size == "large"){
            tempCount+=1;
          }
        }
        objectsAboveB+=tempCount;
      }

        var relation : string = literal.relation

        //Calculations for inside, ontop, and under, which can be approximated without violating admissability
        if (relation === "inside" || relation === "ontop" || relation === "under"){
          if(testState.holding === objectA || testState.holding === objectB){
            return Math.abs(xA-xB) + 3*Math.max(objectsAboveA,objectsAboveB)
          }else{
          distance+=3*objectsAboveB + 5*objectsAboveA + Math.min(armDistanceA,armDistanceB) + 10*Math.abs(xA-xB) +1
          return distance
        }
        } else if (relation === "beside"){
          var moveA : number = 3*objectsAboveA
          var moveB : number = 3*objectsAboveB
          distance += +Math.min(moveA,moveB) + (Math.abs(Math.abs(xA-xB)-1)) + 10*Math.min(armDistanceA,armDistanceB)
          return distance
        }
        else if (relation === "leftof"){
          var moveA : number = 3*objectsAboveA + Math.abs(xB-xA-1)
          var moveB : number = 3*objectsAboveB + Math.abs(xB-xA+1)
          distance += +Math.min(moveA,moveB) + Math.min(armDistanceA,armDistanceB)
          return distance
        } else if (relation === "rightof"){
          var moveA : number = 3*objectsAboveA + Math.abs(xB-xA+1)
          var moveB : number = 3*objectsAboveB + Math.abs(xB-xA-1)
          distance += +Math.min(moveA,moveB) + Math.min(armDistanceA,armDistanceB)
          return distance
        } else if (relation === "above"){
          distance += 3*objectsAboveA + Math.abs(xA-xB) + armDistanceA
          return distance
        }
      return distance
    }

    function getCoords(strKey : string, state : WorldState) : number[]{
      var x : number;
      var y : number;
      if(strKey.substring(0,6) === "floor-"){
        x = Number(strKey.substr(7));
        y = -1;
      }else{
        state.stacks.forEach((stack,index) => {
          if(stack.indexOf(strKey) !=-1){
            x = index;
            y = stack.indexOf(strKey)
          }
        })
      }
      return [x,y]
    }

    // max allocated time for a search in seconds
    var timeout : number = 10;
    var result : SearchResult<WorldState> = aStarSearch<WorldState>(graph,start,goal,heuristic,timeout);
    //Result.path is the resulting series of worldStates we want to traverse to reach the goal.
    //We find the commands (l,r,p,d) by checking how these world states change in order from start to finish
    var previousState : WorldState;
    var currentState : WorldState;
    for(var i=0;i<result.path.length;i++){
      if(i===0){
        //the start node is not included in the result.path
        previousState = start;
      }
      else{
        previousState = result.path[i-1];
      }
      currentState = result.path[i];
      //if the arm has moved right
      if(currentState.arm > previousState.arm){
        plan.push("r")
        continue
      }
      //if the arm has moved left
      if(currentState.arm < previousState.arm){
        plan.push("l")
        continue
      }
      //otherwise what is held has changed
      //if something was picked up
      if(previousState.holding == null){
        plan.push("p")
        continue
      }
      //else something was dropped
      plan.push("d")
    }
    return plan;
  }
  /**
  checks whether a litteral is fullfilled
  */
  function checkLiteral( literal : Interpreter.Literal, state : WorldState) : boolean {
    var bool: boolean = false
    if(literal.relation ==="holding"){
      bool = (state.holding === literal.args[0]);
    }
    else{
      if(checkRelation(literal.args[0],literal.args[1],literal.relation,state)){
        bool = true;
      }
    }
    //return opposite if polarity is false
    if(literal.polarity === false){
      if(bool===false){
        return true
      }
      else{
        return false
      }
    }
    return bool
  }
  /**
  checks if two objects fullfill a relation in a given world state
  Similar to Interpreter.checkRelation() but takes different arguments
  */
  function checkRelation(objA : string, objB : string, relation : string, state : WorldState) : boolean{
    var coordinatesA = Interpreter.getCoords(objA,state);
    // special case: in relation to floor
    if(objB.substring(0,6) ==="floor-"){
      if(coordinatesA[0] === Number(objB.substring(6))){
        if(relation==="above" && coordinatesA[0] === Number(objB.substring(6,7))){
          return true
        }
        if(relation==="ontop" && coordinatesA[0] === Number(objB.substring(6,7))){
          if(coordinatesA[1] === 0){
            return true
          }
        }
      }
      return false
    }
    var coordinatesB : number[] = Interpreter.getCoords(objB,state)
    if(relation === "leftof"){
      if(coordinatesA[0]<coordinatesB[0]){
        return true
      }
    }
    else {if(relation === "rightof"){
      if(coordinatesA[0]>coordinatesB[0]){
        return true
      }
    }
    else {if(relation === "ontop"){
      if(state.objects[objB].form !== "box"){
        if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1] === coordinatesB[1]+1){
          return true
        }
      }
    }
    else {if(relation === "inside"){
      if(state.objects[objB].form === "box"){
        if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1] === coordinatesB[1]+1){
          return true
        }
      }
    }
    else {if(relation === "under"){
      if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1]<coordinatesB[1]){
        return true
      }
    }
    else {if(relation === "beside"){
      if(Math.abs(coordinatesA[0]-coordinatesB[0])===1){
        return true
      }
    }
    else {if(relation === "above"){
      if(coordinatesA[0]===coordinatesB[0] && coordinatesA[1]>coordinatesB[1]){
        return true
      }
    }}}}}}}
    return false
  }

  /** Returns the outgoing edges from a world state node. These are the world states that occur if the
  arm either goes left, right, picks up, or drops an object (if these are possible actions). If a large
  object is moved/picked up the edge cost is 2 otherwise it is 1.
  */
  function getWorldStateEdges(state : WorldState) : Edge<WorldState>[] {
    var edges : Edge<WorldState>[] = [];
    // the cost of a move is 1 if the arm is holding nothing or a small object
    var movementsCost : number =1;
    // the cost is 2 for a large object
    if(state.holding != null && state.objects[state.holding].size === "large"){
      movementsCost = 2;
    }
    //if it's not all the way to the left, then the arm can move left
    if(state.arm !== 0){
      var newState1 : WorldState = deepCloneWorldState(state);
      newState1.arm = newState1.arm - 1;
      var newEdge1 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState1}
      edges.push(newEdge1)
    }
    //if it's not all the way to the right, then the arm can move right
    if(state.arm !== state.stacks.length-1){
      var newState2 : WorldState = deepCloneWorldState(state);
      newState2.arm = newState2.arm + 1;
      var newEdge2 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState2}
      edges.push(newEdge2)
    }
    //if the arm is holding an object
    if(state.holding != null){
      var grabbedObject = state.objects[state.holding];
      var topStackObject = state.objects[state.stacks[state.arm][state.stacks[state.arm].length-1]];
      //if there was no top object, set it to "floor"
      if(topStackObject == null){
        topStackObject = {form : "floor", color : null , size : null}
      }
      //check that grabbedObject can be put ontop or inside topObject
      if(Interpreter.checkPhysicLaws(grabbedObject,topStackObject,"ontop") || Interpreter.checkPhysicLaws(grabbedObject,topStackObject,"inside") ){
        var newState3 : WorldState = deepCloneWorldState(state);
        newState3.stacks[newState3.arm].push(newState3.holding);
        newState3.holding = null;
        var newEdge3 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState3}
        edges.push(newEdge3)
      }
    }

    //if the arm is not holding anything, and there is an object below it, it can pick it up
    else {
      if(state.stacks[state.arm].length > 0){
        var newState4 : WorldState = deepCloneWorldState(state);
        //remove top stack element and put it as held
        newState4.holding = newState4.stacks[newState4.arm].pop();
        // picking up a large object has cost 2
        if(state.objects[newState4.holding].size === "large"){
          movementsCost = 2;
        }
        var newEdge4 : Edge<WorldState> = {from : state, cost : movementsCost, to : newState4}
        edges.push(newEdge4)
      }
    }
    return edges

  }
  /**
  Returns a deep clone of a world state (which can then be changed without affecting the original)
  */
  function deepCloneWorldState(state : WorldState) : WorldState{
    var stacksCopy : string[][] = [[]];
    for(var i =0;i<state.stacks.length;i++){
      stacksCopy[i] = [];
      for(var j =0;j<state.stacks[i].length;j++){
        stacksCopy[i][j] = state.stacks[i][j]
      }
    }
    var newState : WorldState = {
      arm : state.arm,
      holding : state.holding,
      stacks : stacksCopy,
      objects : state.objects,
      examples : state.examples
    }
    return newState
  }

}
